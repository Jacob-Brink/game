if __name__ == '__main__':
    from text import Text
    from events import Event
    from view import View
    from camera import Camera
<<<<<<< HEAD
else:    
    from lib.modules.gui.text import Text
    from event import Event

    
import pygame
    
=======
else:
    from lib.modules.gui.text import Text
    from lib.modules.gui.events import *
    from lib.modules.gui.view import View
    from lib.modules.gui.camera import Camera
    from lib.modules.gui.menu import Menu

from enum import Enum
import pygame

>>>>>>> master
def init():
    pygame.init()
    screen = pygame.display.set_mode((640,480))
    pygame.display.set_caption('The Game')
    pygame.display.flip()
<<<<<<< HEAD
    
    return screen



class Editor(View):

    def __init__(self, level, screen):
        '''
        Constructs an editor object derived from base class View. The editor object allows for easy cration of new levels.
        '''
        
        self._platforms = []
        
        self._screen = screen
        self._level = level
        self._first_click = False
        self.first_pos = None
        self.second_pos = None
        
        self._camera = Camera(pygame.Rect((0,0), screen.get_size()))

    def move_camera(self, events):
        '''
        With given events, controls camera movement.
        '''
        
=======

    return screen

# Cursor enum
class Cursor(Enum):
    platform = 1
    start = 2
    coin = 3
    eraser = 4
# dictionary of width and height for cursor items
ITEM_DIMENSIONS = {
    Cursor.start: (40, 40),
    Cursor.coin: (20, 20)
}
        
    
class Editor(Menu):

    def __init__(self, screen, level, quit_callback):
        '''Constructs an editor object derived from base class View. The editor object allows for easy creation of new levels.'''

        # construct view object that will handle all rendering and blitting stuff
        super().__init__(screen, 'right', 'Editor', ('Platform', self.change_cursor(Cursor.platform)), ('Starting Block', self.change_cursor(Cursor.start)), ('Coin', self.change_cursor(Cursor.coin)),('Exit', quit_callback))

        self._cursor = Cursor.platform
        
        self._platforms = []
        self._level = level

        self._camera = Camera(pygame.Rect((0,0), super().return_screen_dimensions()))

        # coin
        self._coins = []

        # start
        self._start = None
        
        # platforms
        self._first_click = False
        self.first_pos = None
        self.second_pos = None
        self._unfinished_rect = None
        
        self.read_level()

    
    def change_cursor(self, new_cursor):
        '''Changes cursor and is given to buttons in the menu'''
        def callback(*args):
            self._cursor = new_cursor
        return callback
        
    def write_level(self):
        '''Write to level every time a new rectangle is made'''
        with open(self._level, 'a') as level_file:
            print('writing new rectangle...')
            level_file.write(str(self._platforms[-1].x)+ ' ' + str(self._platforms[-1].y) + ' ' + str(self._platforms[-1].w) + ' ' + str(self._platforms[-1].h) + '\n')

    def read_level(self):
        '''Load level platforms into level editor'''
        with open(self._level) as level_file:
            [self._platforms.append(pygame.Rect([int(string_integer) for string_integer in line.strip().split()])) for line in level_file]

    def move_camera(self, events):
        '''With given events, controls camera movement.'''

>>>>>>> master
        keys_pressed = events.keyboard()
        delta_x = 0
        delta_y = 0

<<<<<<< HEAD
        change = .1
        
        if keys_pressed.is_pressed('a'):
            delta_x -= change

        if keys_pressed.is_pressed('d'):
            delta_x += change

        if keys_pressed.is_pressed('w'):
            delta_y -= change

        if keys_pressed.is_pressed('s'):
            delta_y += change

        self._camera.move(delta_x, delta_y)
        
    def _return_rect(self, first_pos, second_pos):
        '''
        Transforms two mouse position points into rectangle.
        '''
=======
        change = 5

        if keys_pressed.is_pressed(pygame.K_a) == Switch.down:
            delta_x -= change

        if keys_pressed.is_pressed(pygame.K_d) == Switch.down:
            delta_x += change

        if keys_pressed.is_pressed(pygame.K_w) == Switch.down:
            delta_y -= change

        if keys_pressed.is_pressed(pygame.K_s) == Switch.down:
            delta_y += change

        self._camera.move(delta_x*events.delta_time(), delta_y*events.delta_time())

    def _return_rect(self, first_pos, second_pos):
        '''Transforms two mouse position points into rectangle.'''
>>>>>>> master

        width = second_pos[0] - first_pos[0]
        height = second_pos[1] - first_pos[1]
        return pygame.Rect(first_pos[0], first_pos[1], width, height)
<<<<<<< HEAD
            
    def update(self, events):
        '''
        Use mouse to drag and make rectangle platforms
        '''
        
        current_click = events.mouse().left_button()

        # first click event
        if current_click and not self._first_click:
            
            self._first_click = True

            # get true first position
            self.first_pos = self._camera.return_true_position(events.mouse().get_position())

            
        # dragging event
        if current_click and self._first_click:

            second_pos = self._camera.return_true_position(events.mouse().get_position())
            
            incomplete_rect = self._return_rect(self.first_pos, second_pos)

            pygame.draw.rect(self._screen, (0,100,0), self._camera.return_display_position(incomplete_rect))

            
        # second click event    
        if self._first_click == True and current_click == False:
=======

    def draw_platform(self, current_click, mouse_position):
        '''Draws platform with mouse clicks'''
        # Start drawing rectangle
        if current_click == Switch.pushed_down and not self._first_click:

            self._first_click = True

            # get true first position
            self.first_pos = self._camera.return_true_position(mouse_position)


        # Continue drawing rectangle
        if current_click == Switch.down and self._first_click:

            # get true second position
            self.second_pos = self._camera.return_true_position(mouse_position)

            self._unfinished_rect = pygame.Rect(self._return_rect(self.first_pos, self.second_pos))
            

        # End drawing of rectangle on second click event
        if self._first_click == True and current_click == Switch.pushed_up:
>>>>>>> master

            # reset first click so new rectangle can be created
            self._first_click = False

            # get true second position
<<<<<<< HEAD
            self.second_pos = self._camera.return_true_position(events.mouse().get_position())
=======
            self.second_pos = self._camera.return_true_position(mouse_position)
>>>>>>> master

            # return rectangles with from two true positions
            self._platforms.append(self._return_rect(self.first_pos, self.second_pos))

<<<<<<< HEAD
            
        for rectangle in self._platforms:
            pygame.draw.rect(self._screen, (0, 255, 0), (self._camera.return_display_position(rectangle), (rectangle.width, rectangle.height)))

=======
            # remove temp rectangle
            self._unfinished_rect = None

            self.write_level()

    def _collides_platform(self, rect):
        '''Checks for collisions, returns boolean value'''
        for rectangle in self._platforms:
            if rectangle.colliderect(rect):
                return True
        return False
            
    def place_item(self, current_click, mouse_pos):
        '''Places an item only if the user places it where it does not overlap with another rectangle'''
        item_rect = pygame.Rect(self._camera.return_true_position(mouse_pos), ITEM_DIMENSIONS[self._cursor])

        if not self._collides_platform(item_rect):
            if current_click == Switch.pushed_up:
                if self._cursor == Cursor.coin:
                    self._coins.append((item_rect.x, item_rect.y))
                if self._cursor == Cursor.start:
                    self._start = item_rect
        print(self._coins)
                
    
    def update(self, events, screen):
        '''Use mouse to drag and make rectangle platforms'''

        current_click = events.mouse().left_button()
        mouse_pos = events.mouse().get_position()
        
        if self._cursor == Cursor.platform:
            self.draw_platform(current_click, events.mouse().get_position())
        elif self._cursor == Cursor.coin or self._cursor == Cursor.start:
            self.place_item(current_click, mouse_pos)
        elif self._cursor == Cursor.eraser:
            self.erase(current_click, mouse_pos)
        
        for rectangle in self._platforms:
            pygame.draw.rect(self._screen, (0, 100, 0), (self._camera.return_display_position((rectangle.x, rectangle.y)), (rectangle.width, rectangle.height)))

        if not self._unfinished_rect == None:
            pygame.draw.rect(self._screen, (0, 255,0), (self._camera.return_display_position((self._unfinished_rect.x, self._unfinished_rect.y)), (self._unfinished_rect.width, self._unfinished_rect.height)))
            
        super().update(events, screen)
>>>>>>> master
        self.move_camera(events)

if __name__ == '__main__':

    screen = init()
    editor = Editor('level', screen)
    event_handler = Event()
<<<<<<< HEAD
    
=======

>>>>>>> master
    running = True

    while running:
        screen.fill((0,0,0))
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                running = False

        event_handler.update(pygame.key.get_pressed(), pygame.mouse.get_pressed(), pygame.mouse.get_pos())
<<<<<<< HEAD
        
                
=======
        pygame.time.Clock().tick(60)
>>>>>>> master
        editor.update(event_handler)
        pygame.display.flip()
